package template

import (
	"fmt"
	"sort"
	"strings"
	"sync"
	"time"
)

// HookContext provides context for generation hooks
type HookContext struct {
	TemplateName string
	Template     string
	Data         any
	Output       string
	Metadata     map[string]any
	IsPreHook    bool
}

// GenerationHook is a function that can modify template data or output
type GenerationHook func(ctx *HookContext) error

type PreHook func(ctx *HookContext) error // modify Data or Metadata
type PostHook func(ctx *HookContext) (string, error)

type HookManager struct {
	mu        sync.RWMutex
	preHooks  map[int][]PreHook
	postHooks map[int][]PostHook
}

func NewHooksManager() *HookManager {
	return &HookManager{
		preHooks:  make(map[int][]PreHook, 0),
		postHooks: make(map[int][]PostHook, 0),
	}
}

// AddPreHook registers a pre generation hook
func (e *HookManager) AddPreHook(hook PreHook, priority ...int) {
	e.mu.Lock()
	defer e.mu.Unlock()

	p := 0
	if len(priority) > 0 {
		p = priority[0]
	}

	hooks, ok := e.preHooks[p]
	if !ok {
		hooks = make([]PreHook, 0)
	}

	e.preHooks[p] = append(hooks, hook)

}

// AddPostHook registers a post generation hook
func (e *HookManager) AddPostHook(hook PostHook, priority ...int) {
	e.mu.Lock()
	defer e.mu.Unlock()

	p := 0
	if len(priority) > 0 {
		p = priority[0]
	}

	hooks, ok := e.postHooks[p]
	if !ok {
		hooks = make([]PostHook, 0)
	}

	e.postHooks[p] = append(hooks, hook)
}

func (e *HookManager) PreHooks() []PreHook {
	e.mu.RLock()
	defer e.mu.RUnlock()

	keys := []int{}
	for k := range e.preHooks {
		keys = append(keys, k)
	}

	sort.Ints(keys)

	out := make([]PreHook, 0)
	for _, priority := range keys {
		out = append(out, e.preHooks[priority]...)
	}

	return out
}

func (e *HookManager) PostHooks() []PostHook {
	e.mu.RLock()
	defer e.mu.RUnlock()

	keys := []int{}
	for k := range e.postHooks {
		keys = append(keys, k)
	}

	sort.Ints(keys)

	out := make([]PostHook, 0)
	for _, priority := range keys {
		out = append(out, e.postHooks[priority]...)
	}

	return out
}

////////////////////////////////////////////////////////////////////////////////

// CommonHooks provides a collection of commonly used hooks
type CommonHooks struct{}

// NewCommonHooks creates a new instance of CommonHooks
func NewCommonHooks() *CommonHooks {
	return &CommonHooks{}
}

// AddTimestampHook adds a timestamp to generated files
func (h *CommonHooks) AddTimestampHook() PostHook {
	return func(ctx *HookContext) (string, error) {
		timestamp := time.Now().Format("2006-01-02 15:04:05")
		header := fmt.Sprintf("// Generated on %s\n", timestamp)

		// Only add to Go files
		if isGoFile(ctx.TemplateName, ctx.Output) {
			return header + ctx.Output, nil
		}
		return ctx.Output, nil
	}
}

// AddCopyrightHook adds a copyright header
func (h *CommonHooks) AddCopyrightHook(copyright string) PostHook {
	return func(ctx *HookContext) (string, error) {
		if copyright == "" {
			return ctx.Output, nil
		}

		header := fmt.Sprintf("// %s\n", copyright)

		// Only add to code files
		if isCodeFile(ctx.TemplateName, ctx.Output) {
			return header + ctx.Output, nil
		}
		return ctx.Output, nil
	}
}

// AddLicenseHook adds a license header
func (h *CommonHooks) AddLicenseHook(license string) PostHook {
	return func(ctx *HookContext) (string, error) {
		if license == "" {
			return ctx.Output, nil
		}

		// Format license as comment block
		lines := strings.Split(license, "\n")
		var header strings.Builder
		header.WriteString("/*\n")
		for _, line := range lines {
			if line != "" {
				header.WriteString(" * ")
				header.WriteString(line)
			}
			header.WriteString("\n")
		}
		header.WriteString(" */\n\n")

		// Only add to code files
		if isCodeFile(ctx.TemplateName, ctx.Output) {
			return header.String() + ctx.Output, nil
		}
		return ctx.Output, nil
	}
}

// AddGeneratedWarningHook adds a warning that the file is generated
func (h *CommonHooks) AddGeneratedWarningHook() PostHook {
	return func(ctx *HookContext) (string, error) {
		warning := "// Code generated by go-template. DO NOT EDIT.\n"

		// Only add to Go files
		if isGoFile(ctx.TemplateName, ctx.Output) {
			return warning + ctx.Output, nil
		}
		return ctx.Output, nil
	}
}

// RemoveTrailingWhitespaceHook removes trailing whitespace from lines
func (h *CommonHooks) RemoveTrailingWhitespaceHook() PostHook {
	return func(ctx *HookContext) (string, error) {
		lines := strings.Split(ctx.Output, "\n")
		for i, line := range lines {
			lines[i] = strings.TrimRight(line, " \t")
		}
		return strings.Join(lines, "\n"), nil
	}
}

// AddMetadataHook adds template metadata for tracking
// By default, template_content is only populated by RenderString
func (h *CommonHooks) AddMetadataHook() PreHook {
	return func(ctx *HookContext) error {
		ctx.Metadata["processed_at"] = time.Now()
		ctx.Metadata["template_name"] = ctx.TemplateName
		ctx.Metadata["template_content"] = ctx.Template
		return nil
	}
}

// ValidateDataHook validates required data fields
func (h *CommonHooks) ValidateDataHook(requiredFields []string) PreHook {
	return func(ctx *HookContext) error {
		data, ok := ctx.Data.(map[string]any)
		if !ok {
			newData, err := convertToContext(ctx.Data)
			if err != nil {
				return fmt.Errorf("unable to coerce data to map: %w", err)
			}
			data = newData
			ctx.Data = newData
		}

		for _, field := range requiredFields {
			if _, exists := data[field]; !exists {
				return fmt.Errorf("required field '%s' is missing", field)
			}
		}
		return nil
	}
}

// SetDefaultsHook sets default values for missing data fields
func (h *CommonHooks) SetDefaultsHook(defaults map[string]any) PreHook {
	return func(ctx *HookContext) error {
		data, ok := ctx.Data.(map[string]any)
		if !ok {
			// Convert to map if it's not already
			newData, err := convertToContext(ctx.Data)
			if err != nil {
				return fmt.Errorf("unable to coerce data to map: %w", err)
			}
			data = newData
			ctx.Data = newData
		}

		for key, value := range defaults {
			if _, exists := data[key]; !exists {
				data[key] = value
			}
		}
		return nil
	}
}

// Helper functions

// isGoFile checks if the output is for a Go file
func isGoFile(templateName, output string) bool {
	return strings.HasSuffix(templateName, ".go") ||
		strings.HasSuffix(templateName, ".go.tpl") ||
		strings.Contains(output, "package ")
}

// isCodeFile checks if the output is for a code file
func isCodeFile(templateName, output string) bool {
	// Check common code file extensions
	codeExtensions := []string{".go", ".js", ".ts", ".py", ".java", ".c", ".cpp", ".h", ".hpp"}
	for _, ext := range codeExtensions {
		if strings.HasSuffix(templateName, ext) || strings.HasSuffix(templateName, ext+".tpl") {
			return true
		}
	}

	// Check for common code patterns in output
	codePatterns := []string{"package ", "import ", "func ", "class ", "def ", "#include"}
	for _, pattern := range codePatterns {
		if strings.Contains(output, pattern) {
			return true
		}
	}

	return false
}
