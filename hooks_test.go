package template_test

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/goliatone/go-template"
	"github.com/stretchr/testify/require"
)

func TestHooks_PostHooks_AddTimestamp(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddTimestampHook())

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	// Should contain timestamp
	require.Contains(t, result, "// Generated on")
	require.Contains(t, result, time.Now().Format("2006-01-02"))
	require.Contains(t, result, "package main")
}

func TestHooks_PostHooks_AddCopyright(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	copyright := "Copyright 2024 MyCompany Inc."
	renderer.RegisterPostHook(hooks.AddCopyrightHook(copyright))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	expected := "// Copyright 2024 MyCompany Inc.\npackage main"
	require.Contains(t, result, expected)
}

func TestHooks_PostHooks_AddLicense(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	license := "MIT License\n\nPermission is hereby granted..."
	renderer.RegisterPostHook(hooks.AddLicenseHook(license))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	require.Contains(t, result, "/*")
	require.Contains(t, result, " * MIT License")
	require.Contains(t, result, " * Permission is hereby granted...")
	require.Contains(t, result, " */")
}

func TestHooks_PostHooks_AddGeneratedWarning(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	expected := "// Code generated by go-template. DO NOT EDIT.\npackage main"
	require.Contains(t, result, expected)
}

func TestHooks_PostHooks_RemoveTrailingWhitespace(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())

	// Use RenderString with content that has trailing spaces
	templateContent := "line1   \nline2\t\t\nline3"
	result, err := renderer.RenderString(templateContent, map[string]any{})
	require.NoError(t, err)

	expected := "line1\nline2\nline3"
	require.Equal(t, expected, result)
}

func TestHooks_PostHooks_OnlyApplyToCodeFiles(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddTimestampHook())
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())

	// Test with non-code file (YAML)
	result, err := renderer.RenderTemplate("config.yaml", map[string]any{
		"name":        "test-app",
		"version":     "1.0.0",
		"environment": "production",
		"features":    []string{"auth", "logging"},
	})
	require.NoError(t, err)

	// Should NOT contain Go-specific headers
	require.NotContains(t, result, "// Generated on")
	require.NotContains(t, result, "// Code generated")
	require.Contains(t, result, "name: test-app")
}

func TestHooks_PreHooks_AddMetadata(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPreHook(hooks.AddMetadataHook())

	// Create a post-hook that uses metadata
	renderer.RegisterPostHook(func(ctx *template.HookContext) (string, error) {
		if processedAt, exists := ctx.Metadata["processed_at"]; exists {
			if _, ok := processedAt.(time.Time); ok {
				return "// Metadata captured\n" + ctx.Output, nil
			}
		}
		return ctx.Output, nil
	})

	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.NoError(t, err)

	require.Contains(t, result, "// Metadata captured")
	require.Contains(t, result, "Hello, Alice! Welcome to TestApp.")
}

func TestHooks_PreHooks_ValidateData(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	requiredFields := []string{"name", "version"}
	renderer.RegisterPreHook(hooks.ValidateDataHook(requiredFields))

	// Test with missing required field
	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name": "Alice",
		// missing "version"
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "required field 'version' is missing")

	// Test with all required fields
	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"version":  "1.0.0",
		"app_name": "TestApp",
	})
	require.NoError(t, err)
	require.Contains(t, result, "Hello, Alice!")
}

func TestHooks_PreHooks_SetDefaults(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	defaults := map[string]any{
		"app_name": "DefaultApp",
		"version":  "0.0.1",
	}
	renderer.RegisterPreHook(hooks.SetDefaultsHook(defaults))

	// Test with partial data - defaults should fill missing values
	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name": "Bob",
		// missing app_name - should use default
	})
	require.NoError(t, err)

	require.Contains(t, result, "Hello, Bob! Welcome to DefaultApp.")

	// Test with complete data - should not override existing values
	result, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Charlie",
		"app_name": "CustomApp",
	})
	require.NoError(t, err)

	require.Contains(t, result, "Hello, Charlie! Welcome to CustomApp.")
}

func TestHooks_MultipleHooks_ExecutionOrder(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()

	// Register multiple post-hooks in specific order
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())
	renderer.RegisterPostHook(hooks.AddTimestampHook())
	renderer.RegisterPostHook(hooks.AddCopyrightHook("Copyright 2024"))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	lines := strings.Split(result, "\n")
	require.GreaterOrEqual(t, len(lines), 3)

	// Verify execution order
	require.Contains(t, lines[0], "Copyright 2024") // Last registered, executed last, appears first
	require.Contains(t, lines[1], "Generated on")   // Second to last
	require.Contains(t, lines[2], "Code generated") // First registered, executed first, appears last of headers
}

func TestHooks_RenderString_WithHooks(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())

	templateContent := "Hello {{ name }}!   \nWelcome to {{ app }}.\t"
	result, err := renderer.RenderString(templateContent, map[string]any{
		"name": "Alice",
		"app":  "TestApp",
	})
	require.NoError(t, err)

	expected := "Hello Alice!\nWelcome to TestApp."
	require.Equal(t, expected, result)
}

func TestHooks_ErrorHandling(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	// Register a pre-hook that always fails
	renderer.RegisterPreHook(func(ctx *template.HookContext) error {
		return fmt.Errorf("validation failed: test error")
	})

	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "pre-hook failed")
	require.Contains(t, err.Error(), "validation failed: test error")
}

func TestHooks_PostHook_ErrorHandling(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	// Register a post-hook that always fails
	renderer.RegisterPostHook(func(ctx *template.HookContext) (string, error) {
		return "", fmt.Errorf("post-processing failed: test error")
	})

	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "post-hook failed")
	require.Contains(t, err.Error(), "post-processing failed: test error")
}

func TestHooks_ConcurrentAccess(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()

	// Register hooks from multiple goroutines
	done := make(chan bool, 3)

	go func() {
		renderer.RegisterPreHook(hooks.AddMetadataHook())
		done <- true
	}()

	go func() {
		renderer.RegisterPostHook(hooks.AddTimestampHook())
		done <- true
	}()

	go func() {
		renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())
		done <- true
	}()

	// Wait for all goroutines to complete
	for range 3 {
		<-done
	}

	// Verify hooks were registered correctly by using them
	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)
	require.Contains(t, result, "Generated on")
	require.Contains(t, result, "package main")
}

func TestHooks_HelperFunctions(t *testing.T) {
	tests := []struct {
		name         string
		templateName string
		templateFile string
		output       string
		expectGo     bool
		expectCode   bool
	}{
		{
			name:         "go_file_by_extension",
			templateName: "test.go",
			templateFile: "test.go.tpl",
			output:       "func main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "go_template_by_extension",
			templateName: "test.go",
			templateFile: "test.go.tpl",
			output:       "func main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "go_file_by_content",
			templateName: "test.txt",
			templateFile: "test.txt.tpl",
			output:       "package main\n\nfunc main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "javascript_file",
			templateName: "test.js",
			templateFile: "test.js.tpl",
			output:       "function main() {}",
			expectGo:     false,
			expectCode:   true,
		},
		{
			name:         "yaml_file",
			templateName: "config.yaml",
			templateFile: "config.yaml.tpl",
			output:       "name: test\nversion: 1.0",
			expectGo:     false,
			expectCode:   false,
		},
		{
			name:         "python_by_content",
			templateName: "script.txt",
			templateFile: "script.txt.tpl",
			output:       "def main():\n    pass",
			expectGo:     false,
			expectCode:   true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Create a temporary template file to test template name detection
			dir := t.TempDir()
			templatePath := filepath.Join(dir, tc.templateFile)
			err := os.WriteFile(templatePath, []byte(tc.output), 0644)
			require.NoError(t, err)

			renderer, err := template.NewRenderer(template.WithBaseDir(dir))
			require.NoError(t, err)

			hooks := template.NewCommonHooks()
			renderer.RegisterPostHook(hooks.AddTimestampHook())       // Go files only
			renderer.RegisterPostHook(hooks.AddCopyrightHook("Test")) // Code files only

			result, err := renderer.RenderTemplate(tc.templateName, map[string]any{})
			require.NoError(t, err)

			if tc.expectGo {
				require.Contains(t, result, "Generated on", "Expected Go file detection for %s", tc.templateName)
			} else {
				require.NotContains(t, result, "Generated on", "Did not expect Go file detection for %s", tc.templateName)
			}

			if tc.expectCode {
				require.Contains(t, result, "// Test", "Expected code file detection for %s", tc.templateName)
			} else {
				require.NotContains(t, result, "// Test", "Did not expect code file detection for %s", tc.templateName)
			}
		})
	}
}
