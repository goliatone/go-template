package template_test

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/goliatone/go-template"
	"github.com/stretchr/testify/require"
)

func TestHooks_PostHooks_AddTimestamp(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddTimestampHook())

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	// Should contain timestamp
	require.Contains(t, result, "// Generated on")
	require.Contains(t, result, time.Now().Format("2006-01-02"))
	require.Contains(t, result, "package main")
}

func TestHooks_PostHooks_AddCopyright(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	copyright := "Copyright 2024 MyCompany Inc."
	renderer.RegisterPostHook(hooks.AddCopyrightHook(copyright))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	expected := "// Copyright 2024 MyCompany Inc.\npackage main"
	require.Contains(t, result, expected)
}

func TestHooks_PostHooks_AddLicense(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	license := "MIT License\n\nPermission is hereby granted..."
	renderer.RegisterPostHook(hooks.AddLicenseHook(license))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	require.Contains(t, result, "/*")
	require.Contains(t, result, " * MIT License")
	require.Contains(t, result, " * Permission is hereby granted...")
	require.Contains(t, result, " */")
}

func TestHooks_PostHooks_AddGeneratedWarning(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	expected := "// Code generated by go-template. DO NOT EDIT.\npackage main"
	require.Contains(t, result, expected)
}

func TestHooks_PostHooks_RemoveTrailingWhitespace(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())

	// Use RenderString with content that has trailing spaces
	templateContent := "line1   \nline2\t\t\nline3"
	result, err := renderer.RenderString(templateContent, map[string]any{})
	require.NoError(t, err)

	expected := "line1\nline2\nline3"
	require.Equal(t, expected, result)
}

func TestHooks_PostHooks_OnlyApplyToCodeFiles(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.AddTimestampHook())
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())

	// Test with non-code file (YAML)
	result, err := renderer.RenderTemplate("config.yaml", map[string]any{
		"name":        "test-app",
		"version":     "1.0.0",
		"environment": "production",
		"features":    []string{"auth", "logging"},
	})
	require.NoError(t, err)

	// Should NOT contain Go-specific headers
	require.NotContains(t, result, "// Generated on")
	require.NotContains(t, result, "// Code generated")
	require.Contains(t, result, "name: test-app")
}

func TestHooks_PreHooks_AddMetadata(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPreHook(hooks.AddMetadataHook())

	// Create a post-hook that uses metadata
	renderer.RegisterPostHook(func(ctx *template.HookContext) (string, error) {
		if processedAt, exists := ctx.Metadata["processed_at"]; exists {
			if _, ok := processedAt.(time.Time); ok {
				return "// Metadata captured\n" + ctx.Output, nil
			}
		}
		return ctx.Output, nil
	})

	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.NoError(t, err)

	require.Contains(t, result, "// Metadata captured")
	require.Contains(t, result, "Hello, Alice! Welcome to TestApp.")
}

func TestHooks_PreHooks_ValidateData(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	requiredFields := []string{"name", "version"}
	renderer.RegisterPreHook(hooks.ValidateDataHook(requiredFields))

	// Test with missing required field
	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name": "Alice",
		// missing "version"
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "required field 'version' is missing")

	// Test with all required fields
	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"version":  "1.0.0",
		"app_name": "TestApp",
	})
	require.NoError(t, err)
	require.Contains(t, result, "Hello, Alice!")
}

func TestHooks_PreHooks_SetDefaults(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	defaults := map[string]any{
		"app_name": "DefaultApp",
		"version":  "0.0.1",
	}
	renderer.RegisterPreHook(hooks.SetDefaultsHook(defaults))

	// Test with partial data - defaults should fill missing values
	result, err := renderer.RenderTemplate("simple", map[string]any{
		"name": "Bob",
		// missing app_name - should use default
	})
	require.NoError(t, err)

	require.Contains(t, result, "Hello, Bob! Welcome to DefaultApp.")

	// Test with complete data - should not override existing values
	result, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Charlie",
		"app_name": "CustomApp",
	})
	require.NoError(t, err)

	require.Contains(t, result, "Hello, Charlie! Welcome to CustomApp.")
}

func TestHooks_MultipleHooks_ExecutionOrder(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()

	// Register multiple post-hooks in specific order
	renderer.RegisterPostHook(hooks.AddGeneratedWarningHook())
	renderer.RegisterPostHook(hooks.AddTimestampHook())
	renderer.RegisterPostHook(hooks.AddCopyrightHook("Copyright 2024"))

	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)

	lines := strings.Split(result, "\n")
	require.GreaterOrEqual(t, len(lines), 3)

	// Verify execution order
	require.Contains(t, lines[0], "Copyright 2024") // Last registered, executed last, appears first
	require.Contains(t, lines[1], "Generated on")   // Second to last
	require.Contains(t, lines[2], "Code generated") // First registered, executed first, appears last of headers
}

func TestHooks_RenderString_WithHooks(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()
	renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())

	templateContent := "Hello {{ name }}!   \nWelcome to {{ app }}.\t"
	result, err := renderer.RenderString(templateContent, map[string]any{
		"name": "Alice",
		"app":  "TestApp",
	})
	require.NoError(t, err)

	expected := "Hello Alice!\nWelcome to TestApp."
	require.Equal(t, expected, result)
}

func TestHooks_ErrorHandling(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	// Register a pre-hook that always fails
	renderer.RegisterPreHook(func(ctx *template.HookContext) error {
		return fmt.Errorf("validation failed: test error")
	})

	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "pre-hook failed")
	require.Contains(t, err.Error(), "validation failed: test error")
}

func TestHooks_PostHook_ErrorHandling(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	// Register a post-hook that always fails
	renderer.RegisterPostHook(func(ctx *template.HookContext) (string, error) {
		return "", fmt.Errorf("post-processing failed: test error")
	})

	_, err = renderer.RenderTemplate("simple", map[string]any{
		"name":     "Alice",
		"app_name": "TestApp",
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "post-hook failed")
	require.Contains(t, err.Error(), "post-processing failed: test error")
}

func TestHooks_ConcurrentAccess(t *testing.T) {
	renderer, err := template.NewRenderer(template.WithBaseDir("testdata"))
	require.NoError(t, err)

	hooks := template.NewCommonHooks()

	// Register hooks from multiple goroutines
	done := make(chan bool, 3)

	go func() {
		renderer.RegisterPreHook(hooks.AddMetadataHook())
		done <- true
	}()

	go func() {
		renderer.RegisterPostHook(hooks.AddTimestampHook())
		done <- true
	}()

	go func() {
		renderer.RegisterPostHook(hooks.RemoveTrailingWhitespaceHook())
		done <- true
	}()

	// Wait for all goroutines to complete
	for range 3 {
		<-done
	}

	// Verify hooks were registered correctly by using them
	result, err := renderer.RenderTemplate("code.go", map[string]any{
		"package_name": "main",
		"struct_name":  "Config",
		"name":         "test",
		"version":      "1.0.0",
	})
	require.NoError(t, err)
	require.Contains(t, result, "Generated on")
	require.Contains(t, result, "package main")
}

func TestHooks_PrioritySorting_PreHooks(t *testing.T) {
	manager := template.NewHooksManager()

	var executionOrder []int

	// Register hooks with different priorities
	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 10)
		return nil
	}, 10)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 5)
		return nil
	}, 5)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 1)
		return nil
	}, 1)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 0)
		return nil
	})

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, -5)
		return nil
	}, -5)

	hooks := manager.PreHooks()
	ctx := &template.HookContext{
		TemplateName: "test",
		Data:         map[string]any{},
		Metadata:     make(map[string]any),
		IsPreHook:    true,
	}

	for _, hook := range hooks {
		err := hook(ctx)
		require.NoError(t, err)
	}

	// Hooks should execute in ascending priority order: -5, 0, 1, 5, 10
	expected := []int{-5, 0, 1, 5, 10}
	require.Equal(t, expected, executionOrder)
}

func TestHooks_PrioritySorting_PostHooks(t *testing.T) {
	manager := template.NewHooksManager()

	var executionOrder []int

	// Register hooks with different priorities
	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionOrder = append(executionOrder, 100)
		return ctx.Output, nil
	}, 100)

	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionOrder = append(executionOrder, 20)
		return ctx.Output, nil
	}, 20)

	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionOrder = append(executionOrder, 0)
		return ctx.Output, nil
	}) // Default priority 0

	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionOrder = append(executionOrder, -10)
		return ctx.Output, nil
	}, -10)

	// Execute hooks and verify order
	hooks := manager.PostHooks()
	ctx := &template.HookContext{
		TemplateName: "test",
		Output:       "test output",
		Metadata:     make(map[string]any),
		IsPreHook:    false,
	}

	for _, hook := range hooks {
		_, err := hook(ctx)
		require.NoError(t, err)
	}

	// Hooks should execute in ascending priority order: -10, 0, 20, 100
	expected := []int{-10, 0, 20, 100}
	require.Equal(t, expected, executionOrder)
}

func TestHooks_PrioritySorting_SamePriority(t *testing.T) {
	manager := template.NewHooksManager()

	var executionOrder []string

	// Register multiple hooks with same priority
	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, "first")
		return nil
	}, 5)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, "second")
		return nil
	}, 5)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, "third")
		return nil
	}, 5)

	// Execute hooks
	hooks := manager.PreHooks()
	ctx := &template.HookContext{
		TemplateName: "test",
		Data:         map[string]any{},
		Metadata:     make(map[string]any),
		IsPreHook:    true,
	}

	for _, hook := range hooks {
		err := hook(ctx)
		require.NoError(t, err)
	}

	// Hooks with same priority should execute in registration order
	expected := []string{"first", "second", "third"}
	require.Equal(t, expected, executionOrder)
}

func TestHooks_PrioritySorting_IntegrationWithHookManager(t *testing.T) {
	manager := template.NewHooksManager()

	var executionMarkers []string

	// Register pre-hooks with different priorities
	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionMarkers = append(executionMarkers, "pre-priority-5")
		return nil
	}, 5)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionMarkers = append(executionMarkers, "pre-priority-1")
		return nil
	}, 1)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionMarkers = append(executionMarkers, "pre-priority-0")
		return nil
	}) // Default priority 0

	// Register post-hooks with different priorities
	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionMarkers = append(executionMarkers, "post-priority-10")
		return "// Priority 10\n" + ctx.Output, nil
	}, 10)

	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionMarkers = append(executionMarkers, "post-priority-3")
		return "// Priority 3\n" + ctx.Output, nil
	}, 3)

	manager.AddPostHook(func(ctx *template.HookContext) (string, error) {
		executionMarkers = append(executionMarkers, "post-priority-0")
		return "// Priority 0\n" + ctx.Output, nil
	}) // Default priority 0

	// Simulate pre-hook execution
	preHooks := manager.PreHooks()
	ctx := &template.HookContext{
		TemplateName: "test",
		Data:         map[string]any{},
		Metadata:     make(map[string]any),
		IsPreHook:    true,
	}

	for _, hook := range preHooks {
		err := hook(ctx)
		require.NoError(t, err)
	}

	// Simulate post-hook execution
	postHooks := manager.PostHooks()
	ctx.IsPreHook = false
	ctx.Output = "Original content"

	output := ctx.Output
	for _, hook := range postHooks {
		var err error
		output, err = hook(&template.HookContext{
			TemplateName: ctx.TemplateName,
			Output:       output,
			Metadata:     ctx.Metadata,
			IsPreHook:    false,
		})
		require.NoError(t, err)
	}

	// Verify execution order: pre-hooks (0, 1, 5) then post-hooks (0, 3, 10)
	expectedOrder := []string{
		"pre-priority-0", "pre-priority-1", "pre-priority-5",
		"post-priority-0", "post-priority-3", "post-priority-10",
	}
	require.Equal(t, expectedOrder, executionMarkers)

	// Verify post-hook content transformations are applied in order
	require.Contains(t, output, "Priority 10")
	require.Contains(t, output, "Priority 3")
	require.Contains(t, output, "Priority 0")
	require.Contains(t, output, "Original content")
}

func TestHooks_PrioritySorting_NegativePriorities(t *testing.T) {
	manager := template.NewHooksManager()

	var executionOrder []int

	// Test with negative priorities
	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, -100)
		return nil
	}, -100)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, -1)
		return nil
	}, -1)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 0)
		return nil
	}, 0)

	manager.AddPreHook(func(ctx *template.HookContext) error {
		executionOrder = append(executionOrder, 1)
		return nil
	}, 1)

	// Execute hooks
	hooks := manager.PreHooks()
	ctx := &template.HookContext{
		TemplateName: "test",
		Data:         map[string]any{},
		Metadata:     make(map[string]any),
		IsPreHook:    true,
	}

	for _, hook := range hooks {
		err := hook(ctx)
		require.NoError(t, err)
	}

	// Should execute in ascending order including negatives
	expected := []int{-100, -1, 0, 1}
	require.Equal(t, expected, executionOrder)
}

func TestHooks_PrioritySorting_EmptyHooks(t *testing.T) {
	manager := template.NewHooksManager()

	// Test with no hooks registered
	preHooks := manager.PreHooks()
	postHooks := manager.PostHooks()

	require.Empty(t, preHooks)
	require.Empty(t, postHooks)
}

func TestHooks_HelperFunctions(t *testing.T) {
	tests := []struct {
		name         string
		templateName string
		templateFile string
		output       string
		expectGo     bool
		expectCode   bool
	}{
		{
			name:         "go_file_by_extension",
			templateName: "test.go",
			templateFile: "test.go.tpl",
			output:       "func main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "go_template_by_extension",
			templateName: "test.go",
			templateFile: "test.go.tpl",
			output:       "func main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "go_file_by_content",
			templateName: "test.txt",
			templateFile: "test.txt.tpl",
			output:       "package main\n\nfunc main() {}",
			expectGo:     true,
			expectCode:   true,
		},
		{
			name:         "javascript_file",
			templateName: "test.js",
			templateFile: "test.js.tpl",
			output:       "function main() {}",
			expectGo:     false,
			expectCode:   true,
		},
		{
			name:         "yaml_file",
			templateName: "config.yaml",
			templateFile: "config.yaml.tpl",
			output:       "name: test\nversion: 1.0",
			expectGo:     false,
			expectCode:   false,
		},
		{
			name:         "python_by_content",
			templateName: "script.txt",
			templateFile: "script.txt.tpl",
			output:       "def main():\n    pass",
			expectGo:     false,
			expectCode:   true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Create a temporary template file to test template name detection
			dir := t.TempDir()
			templatePath := filepath.Join(dir, tc.templateFile)
			err := os.WriteFile(templatePath, []byte(tc.output), 0644)
			require.NoError(t, err)

			renderer, err := template.NewRenderer(template.WithBaseDir(dir))
			require.NoError(t, err)

			hooks := template.NewCommonHooks()
			renderer.RegisterPostHook(hooks.AddTimestampHook())       // Go files only
			renderer.RegisterPostHook(hooks.AddCopyrightHook("Test")) // Code files only

			result, err := renderer.RenderTemplate(tc.templateName, map[string]any{})
			require.NoError(t, err)

			if tc.expectGo {
				require.Contains(t, result, "Generated on", "Expected Go file detection for %s", tc.templateName)
			} else {
				require.NotContains(t, result, "Generated on", "Did not expect Go file detection for %s", tc.templateName)
			}

			if tc.expectCode {
				require.Contains(t, result, "// Test", "Expected code file detection for %s", tc.templateName)
			} else {
				require.NotContains(t, result, "// Test", "Did not expect code file detection for %s", tc.templateName)
			}
		})
	}
}
